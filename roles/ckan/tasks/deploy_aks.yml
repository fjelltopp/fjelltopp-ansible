---
- name: Create CKAN namespace
  command: >
    az aks command invoke --resource-group {{ resource_group_name }} --name {{resource_prefix}}-aks \
    --command "kubectl create namespace {{ application_namespace }}"

# - name: Get database info
#   azure.azcollection.azure_rm_postgresqlserver_info:
#     resource_group: "{{ resource_group_name }}"
#     name: "{{resource_prefix}}-db"
#   register: database_info_output_raw

- name: Get datalake info
  azure.azcollection.azure_rm_storageaccount_info:
    resource_group: "{{ resource_group_name }}"
    name: "{{ storage_account_name }}"
  register: datalake_info_output_raw

- name: Log datalake info
  debug: "msg={{ datalake_info_output_raw }}"

- name: Get private link service info by name
  azure.azcollection.azure_rm_privatelinkservice_info:
    resource_group: "{{ resource_group_name }}"
    name: "{{resource_prefix}}-pe-storage"
  register: datalake_pl_output_raw

- name: Log datalake info
  debug: "msg={{ datalake_pl_output_raw }}"

- name: Show database info
  command: >
    az postgres flexible-server show \
      --resource-group {{ resource_group_name }} \
      --name "{{resource_prefix|lower}}-db002"
  register: database_info_output_raw

- name: Log database info
  debug: "msg={{ database_info_output_raw }}"

- set_fact:
    db_fqdn: "{{ (database_info_output_raw.stdout|from_json).fullyQualifiedDomainName }}"

- name: Log fqdn
  debug: "msg={{ db_fqdn }}"

## TODO move to secrets!
- name: Generate Beaker session secret
  set_fact:
    ckan_beaker_secret: "{{ lookup('community.general.random_string', length=25, special=false) }}"
  when: not ckan_beaker_secret|default(None) 

- name: Generate API token secret
  set_fact:
    ckan_api_secret: "{{ lookup('community.general.random_string', length=64, special=false) }}"
  when: not ckan_api_secret|default(None)  

- name: Set K8S Yaml files
  set_fact:
    k8s_yaml:
      - ckandb_job.yaml
      # - shell.yml # only for dev
      - solr.yaml
      - datapusher.yaml
      - redis.yaml
      - giftless.yaml
      - ckan_volumes.yaml
      - ckan.yaml
      - ckan_ingress.yaml
      # - ckan_cronjob.yaml

- name: Templates k8s files # Is there a better way to do this? it would happen automatically if the file _contents_ were piped to the az/kubectl command  
  template:
    src: "{{ lookup('first_found', 'templates/kubernetes/aks/{{ item }}', 'templates/kubernetes/{{ item }}') }}"
    dest: "{{role_path}}/templates/kubernetes/aks/out/{{ item }}"
  with_items: "{{ k8s_yaml }}"  

# This is nice as it only requires Azure Auth, rather than any network access to the cluster. A private endpoint etc _might_ be better tho?
- name: Deploy CKAN
  command: >
    az aks command invoke \
    --resource-group {{ resource_group_name }} 
    --name {{resource_prefix}}-aks \
    --command "kubectl apply -n {{ application_namespace }} -f {{item}}" \
    --file "{{ lookup('first_found', 'templates/kubernetes/aks/out/{{ item }}') }}"
  with_items: "{{ k8s_yaml }}"



- name: Clean up templated files
  command: >
    rm "{{role_path}}/templates/kubernetes/aks/out/{{ item }}"
  with_items: "{{ k8s_yaml }}"

# - name: Setup backup job
#   kubernetes.core.k8s:
#     state: present
#     definition: "{{ lookup('template', 'templates/kubernetes/{{ item }}') | from_yaml_all|list }}"
#     namespace: "{{ application_namespace }}"
#     kubeconfig: "{{ kubeconfig }}"
#   become: false
#   when: fjelltopp_env_type == 'prod'
#   with_items:
#     - db_backup_cronjob.yaml

# - name: Setup db restore job
#   kubernetes.core.k8s:
#     state: present
#     definition: "{{ lookup('template', 'templates/kubernetes/{{ item }}') | from_yaml_all|list }}"
#     namespace: "{{ application_namespace }}"
#     kubeconfig: "{{ kubeconfig }}"
#   become: false
#   when: fjelltopp_env_type != 'prod' and restore_production_backup
#   with_items:
#     - db_restore_cronjob.yaml
